This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-19T22:19:03.444Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  platform/
    darwin.py
  __init__.py
  activity_monitor.py
  check_password.py
  cli.py
  config.py
  encryption.py
  models.py
  password_dialog.py
  selfspy.py
tests/
  conftest.py
  test_models.py
pyproject.toml
pytest.ini
Readme.md

================================================================
Repository Files
================================================================

================
File: src/platform/darwin.py
================
"""
macOS-specific window and process monitoring using AppKit
"""
import asyncio
from datetime import datetime
from typing import Dict, Optional, Tuple

import AppKit
from Foundation import NSObject, NSRunLoop

class MacOSWindowObserver(NSObject):
    """Observer for macOS window and workspace notifications"""
    
    def init(self):
        """Initialize observer"""
        self = super().init()
        if self is not None:
            self.workspace = AppKit.NSWorkspace.sharedWorkspace()
            self.current_app = None
            self._setup_observers()
        return self
        
    def _setup_observers(self):
        """Set up workspace notifications"""
        notification_center = self.workspace.notificationCenter()
        
        # Register for active application changes
        notification_center.addObserver_selector_name_object_(
            self,
            self.applicationActivated_,
            AppKit.NSWorkspaceDidActivateApplicationNotification,
            None
        )
        
        # Register for window focus changes
        AppKit.NSNotificationCenter.defaultCenter().addObserver_selector_name_object_(
            self,
            self.windowFocused_,
            AppKit.NSWindowDidBecomeMainNotification,
            None
        )

    def applicationActivated_(self, notification) -> None:
        """Handle application activation"""
        self.current_app = notification.userInfo()['NSWorkspaceApplicationKey']

    def windowFocused_(self, notification) -> None:
        """Handle window focus changes"""
        pass

class MacOSWindowTracker:
    """Track active window and process information on macOS"""
    
    def __init__(self):
        self.observer = MacOSWindowObserver.alloc().init()
        
    async def get_active_window(self) -> Dict[str, str]:
        """Get current active window information"""
        workspace = AppKit.NSWorkspace.sharedWorkspace()
        active_app = workspace.activeApplication()
        
        if not active_app:
            return {
                'process': 'unknown',
                'title': 'unknown',
                'bundle': 'unknown'
            }
            
        process_name = active_app['NSApplicationName']
        bundle_id = active_app['NSApplicationBundleIdentifier']
        window_title = self._get_active_window_title()
        
        return {
            'process': process_name,
            'title': window_title,
            'bundle': bundle_id
        }
    
    def _get_active_window_title(self) -> str:
        """Get the title of the active window"""
        windows = AppKit.NSApplication.sharedApplication().windows()
        for window in windows:
            if window.isKeyWindow():
                return window.title() or ''
        return ''
    
    def get_window_geometry(self) -> Tuple[int, int, int, int]:
        """Get the geometry of the active window"""
        windows = AppKit.NSApplication.sharedApplication().windows()
        for window in windows:
            if window.isKeyWindow():
                frame = window.frame()
                screen = window.screen()
                if screen:
                    screen_frame = screen.frame()
                    # Convert coordinates from bottom-left to top-left origin
                    y = int(screen_frame.size.height - (frame.origin.y + frame.size.height))
                    return (
                        int(frame.origin.x),
                        y,
                        int(frame.size.width),
                        int(frame.size.height)
                    )
        return (0, 0, 0, 0)
    
    @staticmethod
    def get_screen_info() -> Dict[str, int]:
        """Get information about connected displays"""
        screens = AppKit.NSScreen.screens()
        primary = screens[0].frame()
        return {
            'primary_width': int(primary.size.width),
            'primary_height': int(primary.size.height),
            'display_count': len(screens)
        }
    
    def cleanup(self):
        """Remove notification observers"""
        AppKit.NSNotificationCenter.defaultCenter().removeObserver_(self.observer)

================
File: src/__init__.py
================
"""
Selfspy - A tool for monitoring and analyzing your computer activity
"""
from pathlib import Path

__version__ = "1.0.0"
__author__ = "nuin"
__email__ = "nuin@genedrift.org"

# Add src directory to Python path
import sys
src_path = str(Path(__file__).parent.absolute())
if src_path not in sys.path:
    sys.path.append(src_path)

from monitor import ActivityMonitor
from activity_store import ActivityStore
from models import Process, Window, Keys, Click

__all__ = [
    'ActivityMonitor',
    'ActivityStore',
    'Process',
    'Window',
    'Keys',
    'Click',
]

================
File: src/activity_monitor.py
================
class ActivityMonitor:
    """macOS activity monitor implementation"""

    async def _check_active_window(self):
        """Check current active window using AppKit"""
        try:
            window_info = await self.window_tracker.get_active_window()
            
            if window_info != self.current_window:
                self.current_window = window_info
                
                # Get window geometry
                x, y, width, height = self.window_tracker.get_window_geometry()
                
                await self.store.update_window_info(
                    process_name=window_info['process'],
                    window_title=window_info['title'],
                    bundle_id=window_info['bundle'],
                    geometry=(x, y, width, height)
                )
                
        except Exception as e:
            logger.error("Window check error", error=str(e))
    
    def _check_permissions(self) -> bool:
        """Check required macOS permissions"""
        try:
            import AppKit
            options = {
                AppKit.kAXTrustedCheckOptionPrompt: True
            }
            return AppKit.AXIsProcessTrustedWithOptions(options)
        except Exception:
            return False

================
File: src/check_password.py
================
"""
Password checking functionality for Selfspy
"""

import os
from typing import Optional
from Crypto.Cipher import Blowfish

DIGEST_NAME = 'password.digest'
MAGIC_STRING = (
    b'\xc5\x7fdh\x05\xf6\xc5=\xcfh\xafv\xc0\xf4\x13i*.O\xf6\xc2\x8d\x0f\x87\xdb'
    b'\x9f\xc2\x88\xac\x95\xf8\xf0\xf4\x96\xe9\x82\xd1\xca[\xe5\xa32\xa0\x03\n'
    b'D\x12\n\x1dr\xbc\x03\x9bE\xd3q6\x89Cwi\x10\x92\xdf(#\x8c\x87\x1b3\xd6\xd4'
    b'\x8f\xde)\xbe\x17\xbf\xe4\xae\xb73\\\xcb\x7f\xd3\xc4\x89\xd0\x88\x07\x90'
    b'\xd8N,\xbd\xbd\x93j\xc7\xa3\xec\xf3P\xff\x11\xde\xc9\xd6 \x98\xe8\xbc\xa0'
    b'|\x83\xe90Nw\xe4=\xb53\x08\xf0\x14\xaa\xf9\x819,X~\x8e\xf7mB\x13\xe9;\xde'
    b'\x9e\x10\xba\x19\x95\xd4p\xa7\xd2\xa9o\xbdF\xcd\x83\xec\xc5R\x17":K\xceAiX'
    b'\xc1\xe8\xbe\xb8\x04m\xbefA8\x99\xee\x00\x93\xb4\x00\xb3\xd4\x8f\x00@Q\xe9'
    b'\xd5\xdd\xff\x8d\x93\xe3w6\x8ctRQK\xa9\x97a\xc1UE\xdfv\xda\x15\xf5\xccA)\xec'
    b'^]AW\x17/h)\x12\x89\x15\x0e#8"\x7f\x16\xd6e\x91\xa6\xd8\xea \xb9\xdb\x93W'
    b'\xce9\xf2a\xe7\xa7T=q'
)

def check(data_dir: str, cipher: Optional[Blowfish.BlowfishCipher], read_only: bool = False) -> bool:
    """Check if the password is correct"""
    fname = os.path.join(data_dir, DIGEST_NAME)
    
    if os.path.exists(fname):
        if cipher is None:
            return False
            
        with open(fname, 'rb') as f:
            stored = f.read()
        return cipher.decrypt(stored) == MAGIC_STRING
        
    else:
        if cipher is not None and not read_only:
            encrypted = cipher.encrypt(MAGIC_STRING)
            with open(fname, 'wb') as f:
                f.write(encrypted)
        return True

def create_cipher(password: str) -> Optional[Blowfish.BlowfishCipher]:
    """Create a Blowfish cipher from password"""
    if not password:
        return None
        
    return Blowfish.new(
        hashlib.md5(password.encode()).digest(),
        Blowfish.MODE_ECB
    )

================
File: src/cli.py
================
# src/cli.py
"""
Modern CLI interface for Selfspy using Typer
"""
import asyncio
import signal
from pathlib import Path
from typing import Optional

import typer
from rich.console import Console
from rich.traceback import install

from .config import Settings
from .activity_store import ActivityStore
from .monitor import ActivityMonitor
from .password_dialog import get_password

# Initialize Typer app and Rich console
app = typer.Typer(help="Selfspy - Monitor and analyze your computer activity")
console = Console()

# Install Rich traceback handler
install(show_locals=True)

@app.command()
def start(
    data_dir: Path = typer.Option(
        None,
        "--data-dir", "-d",
        help="Data directory for storing the database"
    ),
    password: Optional[str] = typer.Option(
        None,
        "--password", "-p",
        help="Encryption password for sensitive data"
    ),
    no_text: bool = typer.Option(
        False,
        "--no-text",
        help="Do not store text data (keystrokes)"
    ),
    debug: bool = typer.Option(
        False,
        "--debug",
        help="Enable debug logging"
    ),
):
    """Start monitoring computer activity."""
    try:
        # Initialize settings
        settings = Settings(
            data_dir=data_dir if data_dir else Settings().data_dir,
            encryption_enabled=not no_text,
            debug=debug
        )
        
        # Get password if needed
        if settings.encryption_enabled and not password:
            password = get_password()
            
        # Set up async monitor
        store = ActivityStore(settings, password)
        monitor = ActivityMonitor(settings, store, debug)
        
        # Handle shutdown signals
        def signal_handler():
            monitor.stop()
            
        for sig in (signal.SIGTERM, signal.SIGINT):
            signal.signal(sig, signal_handler)
        
        # Start monitoring
        console.print("[green]Starting Selfspy monitor...[/green]")
        asyncio.run(monitor.start())
        
    except KeyboardInterrupt:
        console.print("\n[yellow]Shutting down gracefully...[/yellow]")
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")
        raise typer.Exit(1)

@app.command()
def stats(
    data_dir: Path = typer.Option(
        None,
        "--data-dir", "-d",
        help="Data directory containing the database"
    ),
    start_date: str = typer.Option(
        None,
        "--start", "-s",
        help="Start date (YYYY-MM-DD)"
    ),
    end_date: str = typer.Option(
        None,
        "--end", "-e",
        help="End date (YYYY-MM-DD)"
    ),
    format: str = typer.Option(
        "text",
        "--format", "-f",
        help="Output format (text/json/csv)"
    )
):
    """Display activity statistics."""
    try:
        from .stats import generate_stats
        
        settings = Settings(
            data_dir=data_dir if data_dir else Settings().data_dir
        )
        
        stats = generate_stats(
            settings,
            start_date,
            end_date,
            format
        )
        
        if format == "text":
            console.print(stats)
        else:
            typer.echo(stats)
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")
        raise typer.Exit(1)

def main():
    """Main entry point."""
    app()

if __name__ == "__main__":
    main()

================
File: src/config.py
================
"""
Configuration settings for Selfspy using Pydantic
"""
from pathlib import Path
from typing import Optional

from pydantic import BaseSettings, validator
from pydantic.types import DirectoryPath

class Settings(BaseSettings):
    """Settings management using Pydantic"""
    
    # Base settings
    data_dir: DirectoryPath = Path.home() / ".selfspy"
    database_name: str = "selfspy.db"
    debug: bool = False
    read_only: bool = False
    
    # Activity settings
    active_window_check_interval: float = 0.1
    keystroke_buffer_timeout: int = 1
    active_threshold: int = 180  # seconds
    
    # Encryption settings
    encryption_enabled: bool = True
    encryption_digest_name: str = "password.digest"
    
    # Platform-specific settings
    platform_module: str = "default"
    
    @property
    def database_path(self) -> Path:
        """Get the full database path"""
        return self.data_dir / self.database_name
        
    @validator("data_dir")
    def create_data_dir(cls, v: Path) -> Path:
        """Ensure data directory exists"""
        v.mkdir(parents=True, exist_ok=True)
        return v
    
    class Config:
        env_prefix = "SELFSPY_"

================
File: src/encryption.py
================
"""
Encryption utilities for Selfspy
"""
import hashlib
from pathlib import Path
from typing import Optional

from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import padding

MAGIC_STRING = b"selfspy-v2-verification-token"

def create_cipher(password: Optional[str]) -> Optional[Fernet]:
    """Create a Fernet cipher from password"""
    if not password:
        return None
        
    # Use PBKDF2 to derive a key from the password
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b"selfspy-salt",  # In production, use a random salt
        iterations=100000,
    )
    key = kdf.derive(password.encode())
    return Fernet(key)

async def check_password(
    data_dir: Path,
    cipher: Optional[Fernet],
    read_only: bool = False
) -> bool:
    """Check if the password is correct"""
    digest_path = data_dir / "password.digest"
    
    if digest_path.exists():
        if cipher is None:
            return False
            
        stored = digest_path.read_bytes()
        try:
            decrypted = cipher.decrypt(stored)
            return decrypted == MAGIC_STRING
        except:
            return False
    else:
        if cipher is not None and not read_only:
            encrypted = cipher.encrypt(MAGIC_STRING)
            digest_path.write_bytes(encrypted)
        return True

================
File: src/models.py
================
# src/models.py
"""
SQLAlchemy models for Selfspy using modern features
"""
from datetime import datetime
from typing import Optional

from sqlalchemy import Index, ForeignKey, func
from sqlalchemy.orm import (
    DeclarativeBase,
    Mapped,
    mapped_column,
    relationship
)

class Base(DeclarativeBase):
    """Base class for all models"""
    pass

class TimestampMixin:
    """Mixin for timestamp fields"""
    created_at: Mapped[datetime] = mapped_column(default=func.now())
    updated_at: Mapped[datetime] = mapped_column(
        default=func.now(),
        onupdate=func.now()
    )

class Process(TimestampMixin, Base):
    """Process information"""
    __tablename__ = "process"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(index=True)
    
    # Relationships
    windows: Mapped[list["Window"]] = relationship(
        back_populates="process",
        cascade="all, delete-orphan"
    )
    keys: Mapped[list["Keys"]] = relationship(
        back_populates="process",
        cascade="all, delete-orphan"
    )
    clicks: Mapped[list["Click"]] = relationship(
        back_populates="process",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Process '{self.name}'>"

class Window(TimestampMixin, Base):
    """Window information"""
    __tablename__ = "window"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(index=True)
    process_id: Mapped[int] = mapped_column(ForeignKey("process.id"), index=True)
    
    # Metadata
    geometry_x: Mapped[Optional[int]]
    geometry_y: Mapped[Optional[int]]
    geometry_width: Mapped[Optional[int]]
    geometry_height: Mapped[Optional[int]]
    
    # Relationships
    process: Mapped[Process] = relationship(back_populates="windows")
    keys: Mapped[list["Keys"]] = relationship(
        back_populates="window",
        cascade="all, delete-orphan"
    )
    clicks: Mapped[list["Click"]] = relationship(
        back_populates="window",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Window '{self.title}'>"

class Keys(TimestampMixin, Base):
    """Keystroke information"""
    __tablename__ = "keys"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    text: Mapped[bytes]
    nrkeys: Mapped[int] = mapped_column(index=True)
    
    # Foreign keys
    process_id: Mapped[int] = mapped_column(ForeignKey("process.id"), index=True)
    window_id: Mapped[int] = mapped_column(ForeignKey("window.id"))
    
    # Relationships
    process: Mapped[Process] = relationship(back_populates="keys")
    window: Mapped[Window] = relationship(back_populates="keys")

    def decrypt_text(self, cipher=None) -> str:
        """Decrypt stored text"""
        if cipher:
            try:
                decrypted = cipher.decrypt(self.text)
                return decrypted.rstrip(b"\0").decode("utf-8")
            except:
                return ""
        return self.text.decode("utf-8")

class Click(TimestampMixin, Base):
    """Mouse click information"""
    __tablename__ = "click"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    button: Mapped[int]
    x: Mapped[int]
    y: Mapped[int]
    nrmoves: Mapped[int] = mapped_column(default=0)
    
    # Foreign keys
    process_id: Mapped[int] = mapped_column(ForeignKey("process.id"), index=True)
    window_id: Mapped[int] = mapped_column(ForeignKey("window.id"))
    
    # Relationships
    process: Mapped[Process] = relationship(back_populates="clicks")
    window: Mapped[Window] = relationship(back_populates="clicks")

    def __repr__(self) -> str:
        return f"<Click ({self.x}, {self.y}), button={self.button}>"

class Window(TimestampMixin, Base):
    """Window information with macOS-specific fields"""
    __tablename__ = "window"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(index=True)
    process_id: Mapped[int] = mapped_column(ForeignKey("process.id"), index=True)
    
    # macOS specific fields
    bundle_id: Mapped[Optional[str]] = mapped_column(index=True)
    is_minimized: Mapped[bool] = mapped_column(default=False)
    is_fullscreen: Mapped[bool] = mapped_column(default=False)
    
    # Window geometry
    geometry_x: Mapped[Optional[int]]
    geometry_y: Mapped[Optional[int]]
    geometry_width: Mapped[Optional[int]]
    geometry_height: Mapped[Optional[int]]

# src/config.py additions
class Settings(BaseSettings):
    """Settings with macOS-specific options"""
    
    # macOS specific settings
    monitor_suppress_errors: bool = True
    check_accessibility: bool = True
    enable_screen_recording: bool = False  # Requires user approval
    track_window_geometry: bool = True
    
    # Bundle ID filters
    excluded_bundles: list[str] = [
        "com.apple.finder",
        "com.apple.dock",
        "com.apple.systemuiserver"
    ]
    
    class Config:
        env_prefix = "SELFSPY_"



# Add indexes for common queries
Index("ix_process_name_created", Process.name, Process.created_at)
Index("ix_window_title_created", Window.title, Window.created_at)
Index("ix_click_coords", Click.x, Click.y)

================
File: src/password_dialog.py
================
"""
Password dialog functionality for Selfspy
"""

import sys
import getpass
from typing import Optional, Callable
import tkinter as tk
from tkinter import simpledialog

def get_password(verify: Optional[Callable[[str], bool]] = None, 
                message: Optional[str] = None) -> str:
    """Get password from user through GUI or terminal"""
    
    if verify:
        pw = get_keyring_password(verify)
        if pw is not None:
            return pw
    
    return get_user_password(verify, message)

def get_user_password(verify: Optional[Callable[[str], bool]] = None,
                     message: Optional[str] = None,
                     force_save: bool = False) -> str:
    """Get password from user input"""
    
    if sys.stdin.isatty():
        return get_tty_password(verify, message, force_save)
    else:
        return get_tk_password(verify, message, force_save)

def get_keyring_password(verify: Callable[[str], bool],
                        message: Optional[str] = None) -> Optional[str]:
    """Try to get password from system keyring"""
    try:
        import keyring
        username = getpass.getuser()
        pw = keyring.get_password('Selfspy', username)
        
        if pw is not None:
            if verify(pw):
                return pw
            print('Stored keyring password is invalid.')
            pw = get_user_password(verify, message, force_save=True)
            return pw
            
    except ImportError:
        print('keyring library not found')
    
    return None

def set_keyring_password(password: str) -> None:
    """Store password in system keyring"""
    try:
        import keyring
        username = getpass.getuser()
        keyring.set_password('Selfspy', username, password)
    except ImportError:
        print('Unable to save password to keyring (library not found)')
    except Exception as e:
        print(f'Unable to save password to keyring: {e}')

def get_tty_password(verify: Optional[Callable[[str], bool]] = None,
                    message: Optional[str] = None,
                    force_save: bool = False) -> str:
    """Get password from terminal"""
    
    for _ in range(3):
        pw = getpass.getpass(message or 'Password: ')
        if not verify or verify(pw):
            break
    else:
        print('Password verification failed')
        sys.exit(1)

    if force_save or input("Save password to keyring? [y/N]: ").lower() == 'y':
        set_keyring_password(pw)

    return pw

def get_tk_password(verify: Optional[Callable[[str], bool]] = None,
                   message: Optional[str] = None,
                   force_save: bool = False) -> str:
    """Get password using tkinter dialog"""
    
    root = tk.Tk()
    root.withdraw()
    
    while True:
        dialog = PasswordDialog(
            title='Selfspy Password',
            prompt=message or 'Password:',
            parent=root
        )
        
        pw, save = dialog.result
        
        if pw is None:
            return ""
            
        if not verify or verify(pw):
            break
    
    if save or force_save:
        set_keyring_password(pw)
        
    return pw

class PasswordDialog(simpledialog.Dialog):
    """Custom password dialog with save option"""
    
    def __init__(self, title: str, prompt: str, parent: tk.Tk):
        self.prompt = prompt
        super().__init__(parent, title)

    def body(self, master: tk.Frame) -> tk.Entry:
        """Create dialog body"""
        tk.Label(master, text=self.prompt).grid(row=0, sticky=tk.W)
        
        self.password_entry = tk.Entry(master, show='*')
        self.password_entry.grid(row=0, column=1)
        
        self.save_var = tk.BooleanVar()
        tk.Checkbutton(master, 
                      text="Save to keyring",
                      variable=self.save_var).grid(row=1, columnspan=2, sticky=tk.W)
        
        return self.password_entry

    def apply(self) -> None:
        """Store results when OK is clicked"""
        self.result = (self.password_entry.get(), self.save_var.get())

if __name__ == '__main__':
    print(get_password())

================
File: src/selfspy.py
================
"""
Selfspy - Modern Python Activity Monitor
"""

import asyncio
import logging
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any

import structlog
from pynput import mouse, keyboard
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy.future import select

from .models import Base, Process, Window, Keys, Click
from .config import Settings
from .encryption import create_cipher, check_password

logger = structlog.get_logger()

class ActivityMonitor:
    """Modern asynchronous activity monitor"""
    
    def __init__(
        self,
        settings: Settings,
        store: 'ActivityStore',
        debug: bool = False
    ):
        self.settings = settings
        self.store = store
        self.current_window: Optional[Dict[str, str]] = None
        self.buffer: list[Dict[str, Any]] = []
        self.last_activity = datetime.now()
        
        # Configure logging
        log_level = logging.DEBUG if debug else logging.INFO
        structlog.configure(
            wrapper_class=structlog.make_filtering_bound_logger(log_level)
        )
        
        # Initialize listeners
        self.keyboard_listener = keyboard.Listener(
            on_press=self._on_key_press,
            on_release=self._on_key_release
        )
        self.mouse_listener = mouse.Listener(
            on_move=self._on_mouse_move,
            on_click=self._on_mouse_click,
            on_scroll=self._on_scroll
        )

    async def start(self):
        """Start monitoring asynchronously"""
        logger.info("Starting activity monitor...")
        
        self.keyboard_listener.start()
        self.mouse_listener.start()
        
        try:
            while True:
                await self._check_active_window()
                await self._flush_buffer()
                await asyncio.sleep(0.1)
        except asyncio.CancelledError:
            logger.info("Shutting down monitor...")
            await self.stop()
        except Exception as e:
            logger.error("Monitor error", error=str(e))
            await self.stop()
            raise

    async def stop(self):
        """Stop monitoring gracefully"""
        logger.info("Stopping activity monitor...")
        
        self.keyboard_listener.stop()
        self.mouse_listener.stop()
        await self._flush_buffer()
        await self.store.close()

    async def _check_active_window(self):
        """Check current active window"""
        try:
            window_info = await self._get_window_info()
            
            if window_info != self.current_window:
                self.current_window = window_info
                await self.store.update_window_info(
                    window_info['process'],
                    window_info['title']
                )
                
        except Exception as e:
            logger.error("Window check error", error=str(e))

    async def _get_window_info(self) -> Dict[str, str]:
        """Get active window information"""
        # Platform-specific window detection
        # This is a placeholder - actual implementation would use 
        # platform-specific APIs (AppKit, Win32, Xlib etc.)
        return {
            'process': 'unknown',
            'title': 'unknown'
        }

    def _on_key_press(self, key):
        """Handle key press events"""
        try:
            char = key.char if hasattr(key, 'char') else str(key)
            
            self.buffer.append({
                'type': 'key',
                'key': char,
                'time': datetime.now()
            })
            self.last_activity = datetime.now()
            
        except Exception as e:
            logger.error("Key press error", error=str(e))

    def _on_key_release(self, key):
        """Handle key release events"""
        pass

    def _on_mouse_move(self, x: int, y: int):
        """Handle mouse movement"""
        self.last_activity = datetime.now()

    def _on_mouse_click(self, x: int, y: int, button: mouse.Button, pressed: bool):
        """Handle mouse clicks"""
        if pressed:
            try:
                button_num = 1 if button == mouse.Button.left else 3
                asyncio.create_task(self.store.store_click(button_num, x, y))
                self.last_activity = datetime.now()
            except Exception as e:
                logger.error("Mouse click error", error=str(e))

    def _on_scroll(self, x: int, y: int, dx: int, dy: int):
        """Handle scroll events"""
        try:
            button_num = 4 if dy > 0 else 5
            asyncio.create_task(self.store.store_click(button_num, x, y))
            self.last_activity = datetime.now()
        except Exception as e:
            logger.error("Scroll error", error=str(e))

    async def _flush_buffer(self):
        """Flush keystroke buffer to storage"""
        if self.buffer and (datetime.now() - self.last_activity).seconds > 1:
            text = ''.join(
                item['key'] for item in self.buffer 
                if isinstance(item.get('key'), str)
            )
            if text:
                await self.store.store_keys(text)
            self.buffer.clear()

class ActivityStore:
    """Asynchronous activity data store"""
    
    def __init__(
        self,
        settings: Settings,
        password: Optional[str] = None
    ):
        self.settings = settings
        self.engine = create_async_engine(
            f"sqlite+aiosqlite:///{settings.database_path}",
            echo=settings.debug
        )
        self.async_session = sessionmaker(
            self.engine, class_=AsyncSession, expire_on_commit=False
        )
        
        self.cipher = create_cipher(password) if password else None
        self.current_window_id: Optional[int] = None
        self.current_process_id: Optional[int] = None

    async def initialize(self):
        """Initialize database"""
        async with self.engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)

        if self.settings.encryption_enabled:
            await check_password(
                self.settings.data_dir,
                self.cipher,
                self.settings.read_only
            )

    async def update_window_info(self, process_name: str, window_title: str):
        """Update current process and window information"""
        async with self.async_session() as session:
            async with session.begin():
                # Get or create process
                stmt = select(Process).filter_by(name=process_name)
                result = await session.execute(stmt)
                process = result.scalar_one_or_none()
                
                if not process:
                    process = Process(name=process_name)
                    session.add(process)
                    await session.flush()
                
                # Create new window
                window = Window(title=window_title, process_id=process.id)
                session.add(window)
                await session.flush()
                
                self.current_process_id = process.id
                self.current_window_id = window.id

    async def store_keys(self, text: str):
        """Store keystroke data"""
        if not self.current_process_id or not self.current_window_id:
            return
            
        encrypted_text = self._encrypt_text(text)
        
        async with self.async_session() as session:
            async with session.begin():
                keys = Keys(
                    text=encrypted_text,
                    process_id=self.current_process_id,
                    window_id=self.current_window_id
                )
                session.add(keys)

    async def store_click(self, button: int, x: int, y: int):
        """Store mouse click data"""
        if not self.current_process_id or not self.current_window_id:
            return
            
        async with self.async_session() as session:
            async with session.begin():
                click = Click(
                    button=button,
                    x=x,
                    y=y,
                    process_id=self.current_process_id,
                    window_id=self.current_window_id
                )
                session.add(click)

    def _encrypt_text(self, text: str) -> bytes:
        """Encrypt text data"""
        if not self.cipher:
            return text.encode()
            
        padding = 8 - (len(text) % 8)
        padded_text = text + '\0' * padding
        return self.cipher.encrypt(padded_text.encode())

    async def close(self):
        """Clean up database connection"""
        await self.engine.dispose()

================
File: tests/conftest.py
================
"""
Pytest configuration and fixtures
"""
import os
import sys
import tempfile
from pathlib import Path

import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import Session

# Add src to Python path
src_path = str(Path(__file__).parent.parent / 'src')
if src_path not in sys.path:
    sys.path.append(src_path)

from models import Base
from activity_store import ActivityStore

@pytest.fixture(scope="session")
def temp_dir():
    """Create a temporary directory for test data"""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield tmpdir

@pytest.fixture(scope="session")
def db_path(temp_dir):
    """Create a test database path"""
    return os.path.join(temp_dir, "test.db")

@pytest.fixture(scope="function")
def db_session(db_path):
    """Create a new database session for a test"""
    engine = create_engine(f"sqlite:///{db_path}")
    Base.metadata.create_all(engine)
    
    with Session(engine) as session:
        yield session
        
    Base.metadata.drop_all(engine)
    
@pytest.fixture(scope="function")
def activity_store(db_path):
    """Create a test activity store"""
    store = ActivityStore(db_path, password="test")
    yield store
    store.close()

================
File: tests/test_models.py
================
"""
Tests for database models
"""
import sys
from pathlib import Path

import pytest

# Add src to Python path
src_path = str(Path(__file__).parent.parent / 'src')
if src_path not in sys.path:
    sys.path.append(src_path)

from models import Process, Window

def test_process_creation(db_session):
    """Test creating a process"""
    process = Process(name="test_process")
    db_session.add(process)
    db_session.commit()
    
    retrieved = db_session.query(Process).filter_by(name="test_process").first()
    assert retrieved is not None
    assert retrieved.name == "test_process"

def test_window_creation(db_session):
    """Test creating a window with associated process"""
    # Create process first
    process = Process(name="test_process")
    db_session.add(process)
    db_session.commit()
    
    # Create window
    window = Window(title="test_window", process_id=process.id)
    db_session.add(window)
    db_session.commit()
    
    # Test retrieval
    retrieved = db_session.query(Window).filter_by(title="test_window").first()
    assert retrieved is not None
    assert retrieved.title == "test_window"
    assert retrieved.process.name == "test_process"

================
File: pyproject.toml
================
[tool.poetry]
name = "selfspy"
version = "1.0.0"
description = "A tool for monitoring and analyzing your computer activity"
authors = ["nuin <nuin@genedrift.org>"]
readme = "README.md"
packages = [{include = "src"}]
license = "GPL-3.0-or-later"

[tool.poetry.dependencies]
python = "^3.10"
SQLAlchemy = "^2.0.25"
pynput = "^1.7.6"
cryptography = "^41.0.7"
keyring = "^24.3.0"
python-dateutil = "^2.8.2"
click = "^8.1.7"
appdirs = "^1.4.4"
rich = "^13.7.0"
structlog = "^24.1.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.4"
pytest-cov = "^4.1.0"
black = "^23.12.1"
isort = "^5.13.2"
mypy = "^1.8.0"
ruff = "^0.1.11"
pre-commit = "^3.6.0"

[tool.poetry.scripts]
selfspy = "src.cli:main"
selfstats = "src.stats:main"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.pytest.ini_options]
pythonpath = ["src"]
testpaths = ["tests"]
addopts = "-ra -q --cov=src"

================
File: pytest.ini
================
[pytest]
pythonpath = src
testpaths = tests
python_files = test_*.py
addopts = -ra -q --cov=src

================
File: Readme.md
================
# Selfspy

A modern Python tool for monitoring and analyzing your computer activity.

## Description

Selfspy is a daemon that continuously monitors and stores what you are doing on your computer. This includes:
- Keystrokes (encrypted)
- Mouse movements and clicks
- Active window titles and processes
- Activity periods

Perfect for:
- Personal analytics
- Time tracking
- Activity monitoring
- Productivity analysis

## Requirements

- Python 3.10+
- MacOS 10.15+

## Installation

```bash
# Using Poetry
poetry install

# Or using pip
pip install .
```

## Usage

Start monitoring:
```bash
poetry run selfspy
```

View statistics:
```bash
poetry run selfstats
```

## Configuration

Default configuration is stored in `~/.selfspy/`. You can customize the location using:
```bash
poetry run selfspy --data-dir=/path/to/dir
```

## Security

- All keystroke data is encrypted using industry-standard encryption
- Password protection for sensitive data
- Local storage only - no data leaves your computer
- Option to disable text logging

## Contributing

1. Fork the repository
2. Create your feature branch
3. Install development dependencies: `poetry install --with dev`
4. Make your changes
5. Run tests: `poetry run pytest`
6. Submit a pull request

## License

GNU General Public License v3 (GPLv3)
