This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-20T00:22:31.145Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  platform/
    darwin.py
  __init__.py
  activity_monitor.py
  activity_store.py
  check_password.py
  cli.py
  config.py
  encryption.py
  models.py
  password_dialog.py
  stats.py
tests/
  conftest.py
  test_models.py
pyproject.toml
pytest.ini
Readme.md

================================================================
Repository Files
================================================================

================
File: src/platform/darwin.py
================
"""
macOS-specific window and process monitoring using PyObjC
"""
import asyncio
from datetime import datetime
from typing import Dict, Optional, Tuple

import Quartz
import AppKit

class MacOSWindowTracker:
    """Track active window and process information on macOS"""
    
    def __init__(self):
        self.workspace = AppKit.NSWorkspace.sharedWorkspace()
    
    def cleanup(self):
        """Cleanup resources"""
        pass
        
    async def get_active_window(self) -> Dict[str, str]:
        """Get current active window information"""
        active_app = self.workspace.activeApplication()
        
        if not active_app:
            return {
                'process': 'unknown',
                'title': 'unknown',
                'bundle': 'unknown'
            }
            
        return {
            'process': active_app['NSApplicationName'],
            'title': self._get_window_title(active_app),
            'bundle': active_app['NSApplicationBundleIdentifier']
        }
    
    def get_window_geometry(self) -> Tuple[int, int, int, int]:
        """Get current window geometry"""
        try:
            # Get frontmost app info
            app_info = self.workspace.activeApplication()
            if not app_info:
                return (0, 0, 0, 0)
            
            # Get window bounds
            pid = app_info['NSApplicationProcessIdentifier']
            app = AppKit.NSRunningApplication.runningApplicationWithProcessIdentifier_(pid)
            if not app:
                return (0, 0, 0, 0)
            
            # Get window bounds from Accessibility API
            import ApplicationServices as AS
            element = AS.AXUIElementCreateApplication(pid)
            window = None
            
            AS.AXUIElementCopyAttributeValue(element, AS.kAXFocusedWindowAttribute, window)
            if not window:
                return (0, 0, 0, 0)
            
            position = AS.AXValueCreate(AS.kAXValueCGPointType, None)
            size = AS.AXValueCreate(AS.kAXValueCGSizeType, None)
            
            AS.AXUIElementCopyAttributeValue(window, AS.kAXPositionAttribute, position)
            AS.AXUIElementCopyAttributeValue(window, AS.kAXSizeAttribute, size)
            
            x = int(position.x)
            y = int(position.y)
            width = int(size.width)
            height = int(size.height)
            
            return (x, y, width, height)
            
        except Exception:
            return (0, 0, 0, 0)
    
    def _get_window_title(self, app_info: dict) -> str:
        """Get window title for application"""
        try:
            pid = app_info['NSApplicationProcessIdentifier']
            app = AppKit.NSRunningApplication.runningApplicationWithProcessIdentifier_(pid)
            if app:
                return app.localizedName() or 'unknown'
        except:
            pass
        return 'unknown'
    
    def _get_window_frame(self) -> Optional[AppKit.NSRect]:
        """Get frame of active window"""
        try:
            windows = Quartz.CGWindowListCopyWindowInfo(
                Quartz.kCGWindowListOptionOnScreenOnly | 
                Quartz.kCGWindowListExcludeDesktopElements,
                Quartz.kCGNullWindowID
            )
            if windows and windows[0]:
                bounds = windows[0].get(Quartz.kCGWindowBounds)
                if bounds:
                    return AppKit.NSRect(bounds)
        except:
            pass
        return None

================
File: src/__init__.py
================
"""
Selfspy - A tool for monitoring and analyzing your computer activity
"""
from pathlib import Path

__version__ = "1.0.0"
__author__ = "nuin"
__email__ = "nuin@genedrift.org"

# Add src directory to Python path
import sys
src_path = str(Path(__file__).parent.absolute())
if src_path not in sys.path:
    sys.path.append(src_path)

from .activity_monitor import ActivityMonitor
from .activity_store import ActivityStore
from .models import Process, Window, Keys, Click

__all__ = [
    'ActivityMonitor',
    'ActivityStore',
    'Process',
    'Window',
    'Keys',
    'Click',
]

================
File: src/activity_monitor.py
================
"""
Activity monitoring implementation
"""
import asyncio
import logging
import platform
from datetime import datetime
from typing import Optional, Dict, Any

import structlog
from pynput import mouse, keyboard

from .config import Settings
from .platform.darwin import MacOSWindowTracker

import sys
from pathlib import Path

logger = structlog.get_logger()

class ActivityMonitor:
    """Activity monitor implementation"""
    
    def __init__(
        self,
        settings: Settings,
        store: 'ActivityStore',
        debug: bool = False
    ):
        self.settings = settings
        self.store = store
        self.current_window: Optional[Dict[str, str]] = None
        self.buffer: list[Dict[str, Any]] = []
        self.last_activity = datetime.now()
        self.running = False
        
        # Configure logging
        log_level = logging.DEBUG if debug else logging.INFO
        structlog.configure(
            wrapper_class=structlog.make_filtering_bound_logger(log_level)
        )
        
        # Initialize platform-specific window tracker
        if platform.system() == 'Darwin':
            try:
                import Quartz
                import AppKit
                self.window_tracker = MacOSWindowTracker()
            except ImportError:
                logger.error("MacOS libraries not found. Please run: poetry install")
                raise ImportError("Required macOS libraries not found. Run: poetry install")
        else:
            raise NotImplementedError(f"Platform {platform.system()} not supported.")
        
        # Initialize input listeners with all required callbacks
        self.keyboard_listener = keyboard.Listener(
            on_press=self._on_key_press,
            on_release=self._on_key_release
        )
        
        self.mouse_listener = mouse.Listener(
            on_move=self._on_mouse_move,
            on_click=self._on_mouse_click,
            on_scroll=self._on_scroll
        )

    async def start(self):
        """Start monitoring asynchronously"""
        logger.info("Starting activity monitor...")
        
        if not self._check_permissions():
            raise PermissionError(
                "Accessibility permissions required. Please enable in System Preferences."
            )
        
        self.running = True
        self.keyboard_listener.start()
        self.mouse_listener.start()
        
        while self.running:
            try:
                await self._check_active_window()
                await self._flush_buffer()
                await asyncio.sleep(self.settings.active_window_check_interval)
            except Exception as e:
                logger.error("Monitor error", error=str(e))
                if not self.settings.monitor_suppress_errors:
                    raise

    async def stop(self):
        """Stop monitoring gracefully"""
        logger.info("Stopping activity monitor...")
        self.running = False
        
        if self.keyboard_listener.running:
            self.keyboard_listener.stop()
        if self.mouse_listener.running:
            self.mouse_listener.stop()
            
        self.window_tracker.cleanup()
        await self._flush_buffer()
        await self.store.close()

    async def _check_active_window(self):
        """Check current active window"""
        try:
            window_info = await self.window_tracker.get_active_window()
            if window_info != self.current_window:
                self.current_window = window_info
                
                # Get window geometry if enabled
                geometry = None
                if self.settings.track_window_geometry:
                    geometry = self.window_tracker.get_window_geometry()
                
                # Update window info
                await self.store.update_window_info(
                    process_name=window_info['process'],
                    window_title=window_info['title'],
                    bundle=window_info['bundle'],
                    geometry=geometry
                )
                
        except Exception as e:
            if not self.settings.monitor_suppress_errors:
                logger.error("Window check error", error=str(e))
    
    def _check_permissions(self) -> bool:
        """Check required macOS permissions"""
        if not self.settings.check_accessibility:
            return True
        
        try:
            from ApplicationServices import AXIsProcessTrusted
            
            # Direct check for accessibility permissions
            trusted = AXIsProcessTrusted()
            
            if not trusted:
                try:
                    # Try to open System Settings
                    import Foundation
                    url_str = Foundation.NSString.stringWithString_(
                        "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility"
                    )
                    url = Foundation.NSURL.URLWithString_(url_str)
                    Foundation.NSWorkspace.sharedWorkspace().openURL_(url)
                    
                    logger.info(
                        "Waiting for accessibility permissions...\n"
                        "Please enable access in System Settings when prompted"
                    )
                except Exception as e:
                    logger.error("Failed to open System Settings", error=str(e))
                    
            return trusted
                    
        except ImportError:
            logger.error("MacOS libraries not found. Please run: poetry install")
            raise ImportError("Required macOS libraries not found. Run: poetry install")
        except Exception as e:
            if not self.settings.monitor_suppress_errors:
                logger.error("Permission check error", error=str(e))
            return False


    def _on_key_press(self, key):
        """Handle key press events"""
        try:
            char = key.char if hasattr(key, 'char') else str(key)
            
            self.buffer.append({
                'type': 'key',
                'key': char,
                'time': datetime.now()
            })
            self.last_activity = datetime.now()
            
        except Exception as e:
            logger.error("Key press error", error=str(e))

    def _on_key_release(self, key):
        """Handle key release events"""
        pass

    def _on_mouse_move(self, x: int, y: int):
        """Handle mouse movement"""
        self.last_activity = datetime.now()

    def _on_mouse_click(self, x: int, y: int, button: mouse.Button, pressed: bool):
        """Handle mouse clicks"""
        if pressed:
            try:
                button_num = 1 if button == mouse.Button.left else 3
                asyncio.create_task(self.store.store_click(button_num, x, y))
                self.last_activity = datetime.now()
            except Exception as e:
                logger.error("Mouse click error", error=str(e))

    def _on_scroll(self, x: int, y: int, dx: int, dy: int):
        """Handle scroll events"""
        try:
            button_num = 4 if dy > 0 else 5
            asyncio.create_task(self.store.store_click(button_num, x, y))
            self.last_activity = datetime.now()
        except Exception as e:
            logger.error("Scroll error", error=str(e))

    async def _flush_buffer(self):
        """Flush keystroke buffer to storage"""
        if self.buffer and (datetime.now() - self.last_activity).seconds > self.settings.keystroke_buffer_timeout:
            text = ''.join(
                item['key'] for item in self.buffer 
                if isinstance(item.get('key'), str)
            )
            if text:
                await self.store.store_keys(text)
            self.buffer.clear()

================
File: src/activity_store.py
================
"""
Activity data storage implementation
"""
import asyncio
from datetime import datetime
from typing import Optional, Tuple

import structlog
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy.future import select

from .models import Base, Process, Window, Keys, Click
from .config import Settings
from .encryption import create_cipher, check_password

logger = structlog.get_logger()

class ActivityStore:
    """Asynchronous activity data store"""
    
    def __init__(
        self,
        settings: Settings,
        password: Optional[str] = None
    ):
        """Initialize activity store"""
        self.settings = settings
        self.password = password
        
        # Initialize SQLAlchemy engine
        self.engine = create_async_engine(
            f"sqlite+aiosqlite:///{settings.database_path}",
            echo=settings.debug
        )
        
        # Create tables on startup
        async def init_db():
            async with self.engine.begin() as conn:
                await conn.run_sync(Base.metadata.create_all)
                
        asyncio.run(init_db())
        
        self.async_session = sessionmaker(
            self.engine, 
            class_=AsyncSession,
            expire_on_commit=False
        )
        
        self.cipher = create_cipher(password) if password else None
        self.current_window_id: Optional[int] = None
        self.current_process_id: Optional[int] = None

    async def initialize(self):
        """Initialize database"""
        async with self.engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)

        if self.settings.encryption_enabled:
            await check_password(
                self.settings.data_dir,
                self.cipher,
                self.settings.read_only
            )

    async def update_window_info(
        self,
        process_name: str,
        window_title: str,
        bundle: str,
        geometry: Optional[Tuple[int, int, int, int]] = None
    ):
        """Update current window information"""
        async with self.async_session() as session:
            async with session.begin():
                # Get or create process
                process = await session.scalar(
                    select(Process).where(Process.name == process_name)
                )
                if not process:
                    process = Process(name=process_name, bundle_id=bundle)
                    session.add(process)
                    await session.flush()
                
                # Update current process ID
                self.current_process_id = process.id
                
                # Create window record
                window = Window(
                    title=window_title,
                    process_id=process.id
                )
                
                # Add geometry if provided
                if geometry:
                    x, y, width, height = geometry
                    window.x = x
                    window.y = y
                    window.width = width
                    window.height = height
                    
                session.add(window)
                await session.flush()
                
                # Update current window ID
                self.current_window_id = window.id

    async def store_keys(self, text: str):
        """Store keystroke data"""
        if not self.current_process_id or not self.current_window_id:
            return
            
        encrypted_text = self._encrypt_text(text)
        
        async with self.async_session() as session:
            async with session.begin():
                keys = Keys(
                    text=encrypted_text,
                    process_id=self.current_process_id,
                    window_id=self.current_window_id
                )
                session.add(keys)

    async def store_click(self, button: int, x: int, y: int):
        """Store mouse click data"""
        if not self.current_process_id or not self.current_window_id:
            return
            
        async with self.async_session() as session:
            async with session.begin():
                click = Click(
                    button=button,
                    x=x,
                    y=y,
                    process_id=self.current_process_id,
                    window_id=self.current_window_id
                )
                session.add(click)

    def _encrypt_text(self, text: str) -> bytes:
        """Encrypt text data"""
        if not self.cipher:
            return text.encode()
            
        padding = 8 - (len(text) % 8)
        padded_text = text + '\0' * padding
        return self.cipher.encrypt(padded_text.encode())

    async def close(self):
        """Clean up database connection"""
        await self.engine.dispose()

================
File: src/check_password.py
================
"""
Password checking functionality for Selfspy
"""

import os
from typing import Optional
from Crypto.Cipher import Blowfish

DIGEST_NAME = 'password.digest'
MAGIC_STRING = (
    b'\xc5\x7fdh\x05\xf6\xc5=\xcfh\xafv\xc0\xf4\x13i*.O\xf6\xc2\x8d\x0f\x87\xdb'
    b'\x9f\xc2\x88\xac\x95\xf8\xf0\xf4\x96\xe9\x82\xd1\xca[\xe5\xa32\xa0\x03\n'
    b'D\x12\n\x1dr\xbc\x03\x9bE\xd3q6\x89Cwi\x10\x92\xdf(#\x8c\x87\x1b3\xd6\xd4'
    b'\x8f\xde)\xbe\x17\xbf\xe4\xae\xb73\\\xcb\x7f\xd3\xc4\x89\xd0\x88\x07\x90'
    b'\xd8N,\xbd\xbd\x93j\xc7\xa3\xec\xf3P\xff\x11\xde\xc9\xd6 \x98\xe8\xbc\xa0'
    b'|\x83\xe90Nw\xe4=\xb53\x08\xf0\x14\xaa\xf9\x819,X~\x8e\xf7mB\x13\xe9;\xde'
    b'\x9e\x10\xba\x19\x95\xd4p\xa7\xd2\xa9o\xbdF\xcd\x83\xec\xc5R\x17":K\xceAiX'
    b'\xc1\xe8\xbe\xb8\x04m\xbefA8\x99\xee\x00\x93\xb4\x00\xb3\xd4\x8f\x00@Q\xe9'
    b'\xd5\xdd\xff\x8d\x93\xe3w6\x8ctRQK\xa9\x97a\xc1UE\xdfv\xda\x15\xf5\xccA)\xec'
    b'^]AW\x17/h)\x12\x89\x15\x0e#8"\x7f\x16\xd6e\x91\xa6\xd8\xea \xb9\xdb\x93W'
    b'\xce9\xf2a\xe7\xa7T=q'
)

def check(data_dir: str, cipher: Optional[Blowfish.BlowfishCipher], read_only: bool = False) -> bool:
    """Check if the password is correct"""
    fname = os.path.join(data_dir, DIGEST_NAME)
    
    if os.path.exists(fname):
        if cipher is None:
            return False
            
        with open(fname, 'rb') as f:
            stored = f.read()
        return cipher.decrypt(stored) == MAGIC_STRING
        
    else:
        if cipher is not None and not read_only:
            encrypted = cipher.encrypt(MAGIC_STRING)
            with open(fname, 'wb') as f:
                f.write(encrypted)
        return True

def create_cipher(password: str) -> Optional[Blowfish.BlowfishCipher]:
    """Create a Blowfish cipher from password"""
    if not password:
        return None
        
    return Blowfish.new(
        hashlib.md5(password.encode()).digest(),
        Blowfish.MODE_ECB
    )

================
File: src/cli.py
================
# src/cli.py
"""
Modern CLI interface for Selfspy using Typer
"""
import asyncio
import signal
from pathlib import Path
from typing import Optional

import typer
from rich.console import Console
from rich.traceback import install

from .activity_monitor import ActivityMonitor
from .activity_store import ActivityStore
from .config import Settings
from .password_dialog import get_password

# Initialize Typer app and Rich console
app = typer.Typer(help="Selfspy - Monitor and analyze your computer activity")
console = Console()

# Install Rich traceback handler
install(show_locals=True)

@app.command()
def start(
    data_dir: Path = typer.Option(None, "--data-dir", "-d", help="Data directory"),
    password: Optional[str] = typer.Option(None, "--password", "-p", help="Password"),
    no_text: bool = typer.Option(False, "--no-text", help="Don't store text"),
    debug: bool = typer.Option(False, "--debug", help="Enable debug logging"),
):
    """Start monitoring computer activity."""
    try:
        settings = Settings(
            data_dir=data_dir if data_dir else Settings().data_dir,
            encryption_enabled=not no_text,
            debug=debug
        )
        
        if settings.encryption_enabled and not password:
            password = get_password()
            
        store = ActivityStore(settings, password)
        monitor = ActivityMonitor(settings, store, debug)
        
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        def signal_handler(signum, frame):
            if monitor.running:
                loop.create_task(monitor.stop())
                loop.stop()
        
        for sig in (signal.SIGTERM, signal.SIGINT):
            signal.signal(sig, signal_handler)
        
        console.print("[green]Starting Selfspy monitor...[/green]")
        loop.run_until_complete(monitor.start())
        
    except KeyboardInterrupt:
        console.print("\n[yellow]Shutting down gracefully...[/yellow]")
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")
        raise typer.Exit(1)
    finally:
        if 'loop' in locals():
            loop.close()

@app.command()
def stats(
    data_dir: Path = typer.Option(
        None,
        "--data-dir", "-d",
        help="Data directory containing the database"
    ),
    start_date: str = typer.Option(
        None,
        "--start", "-s",
        help="Start date (YYYY-MM-DD)"
    ),
    end_date: str = typer.Option(
        None,
        "--end", "-e",
        help="End date (YYYY-MM-DD)"
    ),
    format: str = typer.Option(
        "text",
        "--format", "-f",
        help="Output format (text/json/csv)"
    )
):
    """Display activity statistics."""
    try:
        from .stats import generate_stats
        
        settings = Settings(
            data_dir=data_dir if data_dir else Settings().data_dir
        )
        
        stats = generate_stats(
            settings,
            start_date,
            end_date,
            format
        )
        
        if format == "text":
            console.print(stats)
        else:
            typer.echo(stats)
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")
        raise typer.Exit(1)


@app.command()
def check_permissions():
    """Check required macOS permissions."""
    try:
        # Import required frameworks
        import objc
        from ApplicationServices import AXIsProcessTrusted
        
        # Direct check for accessibility permissions
        has_accessibility = AXIsProcessTrusted()
        
        # Check screen recording permissions only if explicitly enabled
        settings = Settings()
        has_screen = True  # Default to True if screen recording is not enabled
        if settings.enable_screen_recording:
            has_screen = check_screen_recording_permission()
        
        if has_accessibility and has_screen:
            console.print("[green]All required permissions granted![/green]")
        else:
            # Prepare specific permission messages
            missing_permissions = []
            if not has_accessibility:
                missing_permissions.append("Accessibility")
            if settings.enable_screen_recording and not has_screen:
                missing_permissions.append("Screen Recording")
            
            console.print(
                f"[yellow]Missing permissions: {', '.join(missing_permissions)}[/yellow]\n"
                "Please check System Settings > Privacy & Security > Privacy"
            )
            
            # Try to open System Settings
            try:
                import Foundation
                url_str = Foundation.NSString.stringWithString_("x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility")
                url = Foundation.NSURL.URLWithString_(url_str)
                Foundation.NSWorkspace.sharedWorkspace().openURL_(url)
            except Exception as e:
                console.print("[red]Could not open System Settings automatically[/red]")
            
        # Print detailed status
        console.print("\nPermission Status:")
        console.print(f"Accessibility: {'✓' if has_accessibility else '✗'}")
        if settings.enable_screen_recording:
            console.print(f"Screen Recording: {'✓' if has_screen else '✗'}")
            
    except ImportError as e:
        console.print(f"[red]Error importing macOS frameworks. Make sure you have PyObjC installed: {e}[/red]")
        raise typer.Exit(1)
    except Exception as e:
        console.print(f"[red]Error checking permissions: {e}[/red]")
        raise typer.Exit(1)
def check_screen_recording_permission() -> bool:
    """Check screen recording permission status"""
    try:
        import AVFoundation
        
        session = AVFoundation.AVCaptureSession.alloc().init()
        screen_input = AVFoundation.AVCaptureScreenInput.alloc().init()
        
        if session.canAddInput_(screen_input):
            session.addInput_(screen_input)
            return True
        return False
        
    except Exception:
        return False



def main():
    """Main entry point."""
    app()

if __name__ == "__main__":
    main()

================
File: src/config.py
================
"""
Configuration settings for Selfspy using Pydantic
"""
from pathlib import Path
from typing import Optional

from pydantic import validator
from pydantic_settings import BaseSettings
from pydantic.types import DirectoryPath

class Settings(BaseSettings):
    """Settings management using Pydantic"""
    
    # Base settings
    data_dir: Path = Path.home() / ".selfspy"
    database_name: str = "selfspy.db"
    debug: bool = False
    read_only: bool = False
    
    # Activity settings
    active_window_check_interval: float = 0.1
    keystroke_buffer_timeout: int = 1
    active_threshold: int = 180  # seconds
    track_window_geometry: bool = True
    check_accessibility: bool = True
    monitor_suppress_errors: bool = False
    excluded_bundles: list[str] = []
    
    # Permission settings
    enable_screen_recording: bool = False  # Added this setting
    
    # Encryption settings
    encryption_enabled: bool = True
    encryption_digest_name: str = "password.digest"
    
    # Platform-specific settings
    platform_module: str = "default"
    
    @property
    def database_path(self) -> Path:
        """Get the full database path"""
        return self.data_dir / self.database_name
        
    @validator("data_dir")
    def validate_data_dir(cls, v: Path) -> Path:
        """Ensure data directory exists"""
        if not v.exists():
            v.mkdir(parents=True, exist_ok=True)
        elif not v.is_dir():
            raise ValueError(f"{v} exists but is not a directory")
        return v
    
    class Config:
        env_prefix = "SELFSPY_"

================
File: src/encryption.py
================
"""
Encryption utilities for Selfspy
"""
import hashlib
from pathlib import Path
from typing import Optional

from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import padding
import base64

MAGIC_STRING = b"selfspy-v2-verification-token"

def create_cipher(password: Optional[str]) -> Optional[Fernet]:
    """Create a Fernet cipher from password"""
    if not password:
        return None
        
    # Use PBKDF2 to derive a key from the password
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b"selfspy-salt",
        iterations=100000,
    )
    derived_key = kdf.derive(password.encode())
    key = base64.urlsafe_b64encode(derived_key)
    return Fernet(key)

async def check_password(
    data_dir: Path,
    cipher: Optional[Fernet],
    read_only: bool = False
) -> bool:
    """Check if the password is correct"""
    digest_path = data_dir / "password.digest"
    
    if digest_path.exists():
        if cipher is None:
            return False
            
        stored = digest_path.read_bytes()
        try:
            decrypted = cipher.decrypt(stored)
            return decrypted == MAGIC_STRING
        except:
            return False
    else:
        if cipher is not None and not read_only:
            encrypted = cipher.encrypt(MAGIC_STRING)
            digest_path.write_bytes(encrypted)
        return True

================
File: src/models.py
================
"""
SQLAlchemy models for Selfspy using modern features and macOS support
"""
from datetime import datetime
from typing import Optional

from sqlalchemy import Index, ForeignKey, func, Text, Boolean
from sqlalchemy.orm import (
    DeclarativeBase,
    Mapped,
    mapped_column,
    relationship
)

class Base(DeclarativeBase):
    """Base class for all models"""
    pass

class TimestampMixin:
    """Mixin for timestamp fields"""
    created_at: Mapped[datetime] = mapped_column(default=func.now())
    updated_at: Mapped[datetime] = mapped_column(
        default=func.now(),
        onupdate=func.now()
    )

class Process(TimestampMixin, Base):
    """Process information"""
    __tablename__ = "process"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(index=True)
    bundle_id: Mapped[Optional[str]] = mapped_column(index=True)  # macOS bundle identifier
    
    # Relationships
    windows: Mapped[list["Window"]] = relationship(
        back_populates="process",
        cascade="all, delete-orphan"
    )
    keys: Mapped[list["Keys"]] = relationship(
        back_populates="process",
        cascade="all, delete-orphan"
    )
    clicks: Mapped[list["Click"]] = relationship(
        back_populates="process",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Process '{self.name}'>"

class Window(TimestampMixin, Base):
    """Window information with macOS support"""
    __tablename__ = "window"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(Text, index=True)
    process_id: Mapped[int] = mapped_column(ForeignKey("process.id"), index=True)
    
    # macOS specific fields
    bundle_id: Mapped[Optional[str]] = mapped_column(index=True)
    is_minimized: Mapped[bool] = mapped_column(Boolean, default=False)
    is_fullscreen: Mapped[bool] = mapped_column(Boolean, default=False)
    
    # Window geometry
    geometry_x: Mapped[Optional[int]]
    geometry_y: Mapped[Optional[int]]
    geometry_width: Mapped[Optional[int]]
    geometry_height: Mapped[Optional[int]]
    
    # Screen information
    screen_width: Mapped[Optional[int]]
    screen_height: Mapped[Optional[int]]
    display_index: Mapped[Optional[int]] = mapped_column(default=0)
    
    # Relationships
    process: Mapped[Process] = relationship(back_populates="windows")
    keys: Mapped[list["Keys"]] = relationship(
        back_populates="window",
        cascade="all, delete-orphan"
    )
    clicks: Mapped[list["Click"]] = relationship(
        back_populates="window",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Window '{self.title}'>"

class Keys(TimestampMixin, Base):
    """Keystroke information"""
    __tablename__ = "keys"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    text: Mapped[bytes]  # Encrypted text
    count: Mapped[int] = mapped_column(index=True)  # Number of keystrokes
    
    # Foreign keys
    process_id: Mapped[int] = mapped_column(ForeignKey("process.id"), index=True)
    window_id: Mapped[int] = mapped_column(ForeignKey("window.id"))
    
    # Relationships
    process: Mapped[Process] = relationship(back_populates="keys")
    window: Mapped[Window] = relationship(back_populates="keys")

    def decrypt_text(self, cipher=None) -> str:
        """Decrypt stored text"""
        if cipher:
            try:
                decrypted = cipher.decrypt(self.text)
                return decrypted.decode('utf-8').rstrip('\0')
            except Exception:
                return ""
        return self.text.decode('utf-8')

class Click(TimestampMixin, Base):
    """Mouse click information"""
    __tablename__ = "click"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    button: Mapped[int]  # 1=left, 2=middle, 3=right, 4=scroll up, 5=scroll down
    x: Mapped[int]
    y: Mapped[int]
    
    # Mouse movement tracking
    move_distance: Mapped[int] = mapped_column(default=0)  # Total pixels moved
    move_points: Mapped[Optional[str]]  # JSON string of movement coordinates
    
    # Foreign keys
    process_id: Mapped[int] = mapped_column(ForeignKey("process.id"), index=True)
    window_id: Mapped[int] = mapped_column(ForeignKey("window.id"))
    
    # Relationships
    process: Mapped[Process] = relationship(back_populates="clicks")
    window: Mapped[Window] = relationship(back_populates="clicks")

    def __repr__(self) -> str:
        return f"<Click ({self.x}, {self.y}), button={self.button}>"

# Add indexes for common queries
Index("ix_process_name_created", Process.name, Process.created_at)
Index("ix_process_bundle", Process.bundle_id)
Index("ix_window_title_created", Window.title, Window.created_at)
Index("ix_window_geometry", Window.geometry_x, Window.geometry_y)
Index("ix_click_coords", Click.x, Click.y)
Index("ix_click_timestamp", Click.created_at)

================
File: src/password_dialog.py
================
"""
Password dialog functionality for Selfspy
"""

import getpass
from typing import Optional, Callable
from rich.prompt import Prompt

def get_password(
    verify: Optional[Callable[[str], bool]] = None,
    message: Optional[str] = None,
    force_save: bool = False
) -> str:
    """Get password using Rich prompt"""
    for _ in range(3):
        pw = Prompt.ask(
            message or "Password",
            password=True,
            show_default=False
        )
        if not verify or verify(pw):
            break
    else:
        raise ValueError("Password verification failed")

    if force_save or Prompt.ask(
        "Save password to keyring?",
        choices=["y", "n"],
        default="n"
    ).lower() == "y":
        set_keyring_password(pw)

    return pw

def set_keyring_password(password: str) -> None:
    """Store password in system keyring"""
    try:
        import keyring
        username = getpass.getuser()
        keyring.set_password("Selfspy", username, password)
    except ImportError:
        print("Unable to save password to keyring (library not found)")
    except Exception as e:
        print(f"Unable to save password to keyring: {e}")

if __name__ == '__main__':
    print(get_password())

================
File: src/stats.py
================
"""
Statistics and visualization module for Selfspy
"""
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import json

from sqlalchemy import select, func
from rich.console import Console
from rich.table import Table
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles

from .models import Process, Window, Keys, Click
from .config import Settings
from .activity_store import ActivityStore

console = Console()
app = FastAPI(title="Selfspy Stats")

class StatsGenerator:
    """Generate statistics from activity data"""
    
    def __init__(self, store: ActivityStore):
        self.store = store
        
    async def get_process_stats(
        self, 
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> List[Dict]:
        """Get process usage statistics"""
        async with self.store.async_session() as session:
            query = select(
                Process.name,
                Process.bundle_id,
                func.count(Window.id).label('window_count'),
                func.sum(Keys.count).label('keystroke_count'),
                func.count(Click.id).label('click_count')
            ).join(Window).outerjoin(Keys).outerjoin(Click)
            
            if start_date:
                query = query.where(Window.created_at >= start_date)
            if end_date:
                query = query.where(Window.created_at <= end_date)
                
            query = query.group_by(Process.id).order_by(func.count(Window.id).desc())
            
            result = await session.execute(query)
            return [
                {
                    'name': row.name,
                    'bundle_id': row.bundle_id,
                    'window_count': row.window_count,
                    'keystroke_count': row.keystroke_count or 0,
                    'click_count': row.click_count or 0
                }
                for row in result
            ]
            
    async def get_hourly_activity(
        self,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> List[Dict]:
        """Get hourly activity patterns"""
        async with self.store.async_session() as session:
            query = select(
                func.strftime('%H', Window.created_at).label('hour'),
                func.count(Window.id).label('window_count'),
                func.count(Keys.id).label('keystroke_count'),
                func.count(Click.id).label('click_count')
            ).outerjoin(Keys).outerjoin(Click)
            
            if start_date:
                query = query.where(Window.created_at >= start_date)
            if end_date:
                query = query.where(Window.created_at <= end_date)
                
            query = query.group_by('hour').order_by('hour')
            
            result = await session.execute(query)
            return [
                {
                    'hour': int(row.hour),
                    'window_count': row.window_count,
                    'keystroke_count': row.keystroke_count,
                    'click_count': row.click_count
                }
                for row in result
            ]
            
    async def get_active_periods(
        self,
        threshold: int = 300,  # 5 minutes
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> List[Tuple[datetime, datetime]]:
        """Get active time periods"""
        async with self.store.async_session() as session:
            # Get all activity timestamps
            query = select(Window.created_at).union(
                select(Keys.created_at),
                select(Click.created_at)
            ).order_by('created_at')
            
            if start_date:
                query = query.where(Window.created_at >= start_date)
            if end_date:
                query = query.where(Window.created_at <= end_date)
                
            result = await session.execute(query)
            timestamps = [row[0] for row in result]
            
            # Find active periods
            active_periods = []
            if not timestamps:
                return active_periods
                
            period_start = timestamps[0]
            last_time = timestamps[0]
            
            for timestamp in timestamps[1:]:
                if (timestamp - last_time).total_seconds() > threshold:
                    active_periods.append((period_start, last_time))
                    period_start = timestamp
                last_time = timestamp
                
            active_periods.append((period_start, last_time))
            return active_periods

    def format_text_report(
        self,
        process_stats: List[Dict],
        hourly_stats: List[Dict],
        active_periods: List[Tuple[datetime, datetime]]
    ) -> str:
        """Format statistics as text report"""
        # Process table
        process_table = Table(title="Process Usage")
        process_table.add_column("Process")
        process_table.add_column("Windows")
        process_table.add_column("Keystrokes")
        process_table.add_column("Clicks")
        
        for proc in process_stats[:10]:  # Top 10
            process_table.add_row(
                proc['name'],
                str(proc['window_count']),
                str(proc['keystroke_count']),
                str(proc['click_count'])
            )
            
        # Activity periods
        total_active_time = sum(
            (end - start).total_seconds()
            for start, end in active_periods
        )
        
        # Format report
        report = []
        report.append(process_table)
        report.append(f"\nTotal active time: {timedelta(seconds=total_active_time)}")
        
        return "\n".join(str(line) for line in report)

# FastAPI routes for web visualization
@app.get("/", response_class=HTMLResponse)
async def stats_dashboard():
    """Render stats dashboard"""
    return """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Selfspy Stats</title>
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    </head>
    <body class="bg-gray-100">
        <div class="container mx-auto px-4 py-8">
            <h1 class="text-3xl font-bold mb-8">Activity Statistics</h1>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-lg shadow">
                    <div id="processChart"></div>
                </div>
                <div class="bg-white p-6 rounded-lg shadow">
                    <div id="hourlyChart"></div>
                </div>
            </div>
            
            <div class="mt-8 bg-white p-6 rounded-lg shadow">
                <div id="timelineChart"></div>
            </div>
        </div>
        
        <script>
            async function loadStats() {
                const [processes, hourly, periods] = await Promise.all([
                    fetch('/api/processes').then(r => r.json()),
                    fetch('/api/hourly').then(r => r.json()),
                    fetch('/api/periods').then(r => r.json())
                ]);
                
                // Process chart
                Plotly.newPlot('processChart', [{
                    type: 'bar',
                    x: processes.map(p => p.name),
                    y: processes.map(p => p.window_count),
                    name: 'Windows'
                }], {
                    title: 'Process Usage',
                    barmode: 'stack'
                });
                
                // Hourly chart
                Plotly.newPlot('hourlyChart', [{
                    type: 'scatter',
                    x: hourly.map(h => h.hour),
                    y: hourly.map(h => h.window_count),
                    name: 'Activity'
                }], {
                    title: 'Hourly Activity',
                    xaxis: {title: 'Hour'},
                    yaxis: {title: 'Activity Count'}
                });
                
                // Timeline
                Plotly.newPlot('timelineChart', [{
                    type: 'scatter',
                    x: periods.map(p => p.start),
                    y: periods.map(() => 1),
                    mode: 'markers',
                    name: 'Active Periods'
                }], {
                    title: 'Activity Timeline',
                    xaxis: {
                        type: 'date',
                        title: 'Time'
                    },
                    yaxis: {
                        visible: false
                    }
                });
            }
            
            loadStats();
        </script>
    </body>
    </html>
    """

@app.get("/api/processes")
async def get_processes(
    store: ActivityStore,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None
):
    """Get process statistics"""
    stats = StatsGenerator(store)
    return await stats.get_process_stats(
        datetime.fromisoformat(start_date) if start_date else None,
        datetime.fromisoformat(end_date) if end_date else None
    )

@app.get("/api/hourly")
async def get_hourly(
    store: ActivityStore,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None
):
    """Get hourly statistics"""
    stats = StatsGenerator(store)
    return await stats.get_hourly_activity(
        datetime.fromisoformat(start_date) if start_date else None,
        datetime.fromisoformat(end_date) if end_date else None
    )

@app.get("/api/periods")
async def get_periods(
    store: ActivityStore,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None
):
    """Get active periods"""
    stats = StatsGenerator(store)
    periods = await stats.get_active_periods(
        start_date=datetime.fromisoformat(start_date) if start_date else None,
        end_date=datetime.fromisoformat(end_date) if end_date else None
    )
    return [
        {'start': start.isoformat(), 'end': end.isoformat()}
        for start, end in periods
    ]

def main():
    """CLI entry point"""
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)

if __name__ == "__main__":
    main()

================
File: tests/conftest.py
================
"""
Pytest configuration and fixtures
"""
import os
import sys
import tempfile
from pathlib import Path

import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import Session

# Add src to Python path
src_path = str(Path(__file__).parent.parent / 'src')
if src_path not in sys.path:
    sys.path.append(src_path)

from models import Base
from activity_store import ActivityStore

@pytest.fixture(scope="session")
def temp_dir():
    """Create a temporary directory for test data"""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield tmpdir

@pytest.fixture(scope="session")
def db_path(temp_dir):
    """Create a test database path"""
    return os.path.join(temp_dir, "test.db")

@pytest.fixture(scope="function")
def db_session(db_path):
    """Create a new database session for a test"""
    engine = create_engine(f"sqlite:///{db_path}")
    Base.metadata.create_all(engine)
    
    with Session(engine) as session:
        yield session
        
    Base.metadata.drop_all(engine)
    
@pytest.fixture(scope="function")
def activity_store(db_path):
    """Create a test activity store"""
    store = ActivityStore(db_path, password="test")
    yield store
    store.close()

================
File: tests/test_models.py
================
"""
Tests for database models
"""
import sys
from pathlib import Path

import pytest

# Add src to Python path
src_path = str(Path(__file__).parent.parent / 'src')
if src_path not in sys.path:
    sys.path.append(src_path)

from models import Process, Window

def test_process_creation(db_session):
    """Test creating a process"""
    process = Process(name="test_process")
    db_session.add(process)
    db_session.commit()
    
    retrieved = db_session.query(Process).filter_by(name="test_process").first()
    assert retrieved is not None
    assert retrieved.name == "test_process"

def test_window_creation(db_session):
    """Test creating a window with associated process"""
    # Create process first
    process = Process(name="test_process")
    db_session.add(process)
    db_session.commit()
    
    # Create window
    window = Window(title="test_window", process_id=process.id)
    db_session.add(window)
    db_session.commit()
    
    # Test retrieval
    retrieved = db_session.query(Window).filter_by(title="test_window").first()
    assert retrieved is not None
    assert retrieved.title == "test_window"
    assert retrieved.process.name == "test_process"

================
File: pyproject.toml
================
[tool.poetry]
name = "selfspy"
version = "1.0.0"
description = "A tool for monitoring and analyzing your computer activity"
authors = ["nuin <nuin@genedrift.org>"]
readme = "README.md"
packages = [{include = "src"}]
license = "GPL-3.0-or-later"

[tool.poetry.dependencies]
python = "^3.10"
SQLAlchemy = "^2.0.25"
aiosqlite = "^0.19.0"
pynput = "^1.7.6"
cryptography = "^41.0.7"
keyring = "^24.3.0"
python-dateutil = "^2.8.2"
typer = "^0.9.0"
appdirs = "^1.4.4"
rich = "^13.7.0"
structlog = "^24.1.0"
fastapi = "^0.109.0"
uvicorn = "^0.27.0"
plotly = "^5.18.0"
pandas = "^2.1.4"
pydantic-settings = "^2.1.0"
pyobjc-framework-Quartz = { version = "^9.2", platform = "darwin" }
greenlet = "^3.0.1"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.4"
pytest-cov = "^4.1.0"
pytest-asyncio = "^0.23.3"
black = "^23.12.1"
isort = "^5.13.2"
mypy = "^1.8.0"
ruff = "^0.1.11"
pre-commit = "^3.6.0"

[tool.poetry.scripts]
selfspy = "src.cli:main"
selfstats = "src.stats:main"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.pytest.ini_options]
pythonpath = ["src"]
testpaths = ["tests"]
addopts = "-ra -q --cov=src"

[tool.black]
line-length = 88
target-version = ['py310']

[tool.isort]
profile = "black"
multi_line_output = 3

[tool.mypy]
python_version = "3.10"
ignore_missing_imports = true
check_untyped_defs = true

================
File: pytest.ini
================
[pytest]
pythonpath = src
testpaths = tests
python_files = test_*.py
addopts = -ra -q --cov=src

================
File: Readme.md
================
# Selfspy

A modern Python tool for monitoring and analyzing your computer activity.

## Description

Selfspy is a daemon that continuously monitors and stores what you are doing on your computer. This includes:
- Keystrokes (encrypted)
- Mouse movements and clicks
- Active window titles and processes
- Activity periods

Perfect for:
- Personal analytics
- Time tracking
- Activity monitoring
- Productivity analysis

## Requirements

- Python 3.10+
- MacOS 10.15+

## Installation

```bash
# Using Poetry
poetry install

# Or using pip
pip install .
```

## Usage

Start monitoring:
```bash
poetry run selfspy
```

View statistics:
```bash
poetry run selfstats
```

## Configuration

Default configuration is stored in `~/.selfspy/`. You can customize the location using:
```bash
poetry run selfspy --data-dir=/path/to/dir
```

## Security

- All keystroke data is encrypted using industry-standard encryption
- Password protection for sensitive data
- Local storage only - no data leaves your computer
- Option to disable text logging

## Contributing

1. Fork the repository
2. Create your feature branch
3. Install development dependencies: `poetry install --with dev`
4. Make your changes
5. Run tests: `poetry run pytest`
6. Submit a pull request

## License

GNU General Public License v3 (GPLv3)
