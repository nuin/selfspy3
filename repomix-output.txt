This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-19T22:04:58.773Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  __init__.py
  check_password.py
  cli.py
  config.py
  models.py
  password_dialog.py
  selfspy.py
tests/
  conftest.py
  test_models.py
pyproject.toml
pytest.ini
Readme.md

================================================================
Repository Files
================================================================

================
File: src/__init__.py
================
"""
Selfspy - A tool for monitoring and analyzing your computer activity
"""
from pathlib import Path

__version__ = "1.0.0"
__author__ = "nuin"
__email__ = "nuin@genedrift.org"

# Add src directory to Python path
import sys
src_path = str(Path(__file__).parent.absolute())
if src_path not in sys.path:
    sys.path.append(src_path)

from monitor import ActivityMonitor
from activity_store import ActivityStore
from models import Process, Window, Keys, Click

__all__ = [
    'ActivityMonitor',
    'ActivityStore',
    'Process',
    'Window',
    'Keys',
    'Click',
]

================
File: src/check_password.py
================
"""
Password checking functionality for Selfspy
"""

import os
from typing import Optional
from Crypto.Cipher import Blowfish

DIGEST_NAME = 'password.digest'
MAGIC_STRING = (
    b'\xc5\x7fdh\x05\xf6\xc5=\xcfh\xafv\xc0\xf4\x13i*.O\xf6\xc2\x8d\x0f\x87\xdb'
    b'\x9f\xc2\x88\xac\x95\xf8\xf0\xf4\x96\xe9\x82\xd1\xca[\xe5\xa32\xa0\x03\n'
    b'D\x12\n\x1dr\xbc\x03\x9bE\xd3q6\x89Cwi\x10\x92\xdf(#\x8c\x87\x1b3\xd6\xd4'
    b'\x8f\xde)\xbe\x17\xbf\xe4\xae\xb73\\\xcb\x7f\xd3\xc4\x89\xd0\x88\x07\x90'
    b'\xd8N,\xbd\xbd\x93j\xc7\xa3\xec\xf3P\xff\x11\xde\xc9\xd6 \x98\xe8\xbc\xa0'
    b'|\x83\xe90Nw\xe4=\xb53\x08\xf0\x14\xaa\xf9\x819,X~\x8e\xf7mB\x13\xe9;\xde'
    b'\x9e\x10\xba\x19\x95\xd4p\xa7\xd2\xa9o\xbdF\xcd\x83\xec\xc5R\x17":K\xceAiX'
    b'\xc1\xe8\xbe\xb8\x04m\xbefA8\x99\xee\x00\x93\xb4\x00\xb3\xd4\x8f\x00@Q\xe9'
    b'\xd5\xdd\xff\x8d\x93\xe3w6\x8ctRQK\xa9\x97a\xc1UE\xdfv\xda\x15\xf5\xccA)\xec'
    b'^]AW\x17/h)\x12\x89\x15\x0e#8"\x7f\x16\xd6e\x91\xa6\xd8\xea \xb9\xdb\x93W'
    b'\xce9\xf2a\xe7\xa7T=q'
)

def check(data_dir: str, cipher: Optional[Blowfish.BlowfishCipher], read_only: bool = False) -> bool:
    """Check if the password is correct"""
    fname = os.path.join(data_dir, DIGEST_NAME)
    
    if os.path.exists(fname):
        if cipher is None:
            return False
            
        with open(fname, 'rb') as f:
            stored = f.read()
        return cipher.decrypt(stored) == MAGIC_STRING
        
    else:
        if cipher is not None and not read_only:
            encrypted = cipher.encrypt(MAGIC_STRING)
            with open(fname, 'wb') as f:
                f.write(encrypted)
        return True

def create_cipher(password: str) -> Optional[Blowfish.BlowfishCipher]:
    """Create a Blowfish cipher from password"""
    if not password:
        return None
        
    return Blowfish.new(
        hashlib.md5(password.encode()).digest(),
        Blowfish.MODE_ECB
    )

================
File: src/cli.py
================
"""
Command Line Interface for Selfspy
"""

import os
import sys
from pathlib import Path
from typing import Optional

import click
from rich.console import Console
from rich.traceback import install

from .config import DATA_DIR
from .activity_store import ActivityStore
from .monitor import ActivityMonitor
from .password_dialog import get_password

# Install rich traceback handler
install()
console = Console()

@click.group()
@click.version_option()
def cli():
    """Selfspy - Monitor and analyze your computer activity."""
    pass

@cli.command()
@click.option(
    '-d', '--data-dir',
    type=click.Path(),
    default=DATA_DIR,
    help='Data directory for storing the database'
)
@click.option(
    '-p', '--password',
    help='Encryption password for sensitive data'
)
@click.option(
    '--no-text',
    is_flag=True,
    help='Do not store text data (keystrokes)'
)
@click.option(
    '--debug',
    is_flag=True,
    help='Enable debug logging'
)
def start(
    data_dir: str,
    password: Optional[str],
    no_text: bool,
    debug: bool
) -> None:
    """Start monitoring computer activity."""
    try:
        # Ensure data directory exists
        data_dir = os.path.expanduser(data_dir)
        Path(data_dir).mkdir(parents=True, exist_ok=True)
        
        if not no_text and not password:
            password = get_password()
            
        store = ActivityStore(
            os.path.join(data_dir, 'selfspy.sqlite'),
            password if not no_text else None
        )
        
        monitor = ActivityMonitor(store, debug=debug)
        
        console.print("[green]Starting Selfspy monitor...[/green]")
        monitor.start()
        
    except KeyboardInterrupt:
        console.print("\n[yellow]Shutting down gracefully...[/yellow]")
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        sys.exit(1)

def main():
    """Main entry point."""
    cli()

if __name__ == '__main__':
    main()

================
File: src/config.py
================
"""
Configuration settings for Selfspy
"""

import os

DATA_DIR = os.path.expanduser('~/.selfspy')
DBNAME = 'selfspy.sqlite'
LOCK_FILE = 'selfspy.pid'
LOCK = None

# Activity threshold in seconds
ACTIVE_SECONDS = 180

# Encryption settings
DIGEST_NAME = 'password.digest'

================
File: src/models.py
================
"""
SQLAlchemy models for Selfspy
"""

import zlib
import json
import re
from datetime import datetime
from typing import Optional, Dict, Any, List

from sqlalchemy.ext.declarative import declarative_base, declared_attr
from sqlalchemy import (
    Index, Column, Boolean, Integer, String, DateTime, Binary, ForeignKey,
    create_engine
)
from sqlalchemy.orm import sessionmaker, relationship, backref

Base = declarative_base()

def initialize(fname: str) -> sessionmaker:
    """Initialize the database"""
    engine = create_engine(f'sqlite:///{fname}')
    Base.metadata.create_all(engine)
    return sessionmaker(bind=engine)

class SpookMixin:
    """Base mixin for all models"""
    
    @declared_attr
    def __tablename__(cls):
        return cls.__name__.lower()

    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, default=datetime.now, index=True)

class Process(SpookMixin, Base):
    """Model for storing process information"""
    name = Column(String, index=True, unique=True)

    def __init__(self, name: str):
        self.name = name

    def __repr__(self) -> str:
        return f"<Process '{self.name}'>"

class Window(SpookMixin, Base):
    """Model for storing window information"""
    title = Column(String, index=True)
    process_id = Column(Integer, ForeignKey('process.id'), nullable=False, index=True)
    
    process = relationship("Process", backref=backref('windows'))

    def __init__(self, title: str, process_id: int):
        self.title = title
        self.process_id = process_id

    def __repr__(self) -> str:
        return f"<Window '{self.title}'>"

class Keys(SpookMixin, Base):
    """Model for storing keystroke information"""
    text = Column(Binary, nullable=False)
    process_id = Column(Integer, ForeignKey('process.id'), nullable=False, index=True)
    window_id = Column(Integer, ForeignKey('window.id'), nullable=False)
    nrkeys = Column(Integer, index=True)
    
    process = relationship("Process", backref=backref('keys'))
    window = relationship("Window", backref=backref('keys'))

    def __init__(self, text: bytes, nrkeys: int, process_id: int, window_id: int):
        self.text = text
        self.nrkeys = nrkeys
        self.process_id = process_id
        self.window_id = window_id

    def decrypt_text(self, cipher=None) -> str:
        """Decrypt the stored text"""
        if cipher:
            try:
                decrypted = cipher.decrypt(self.text)
                return decrypted.rstrip(b'\0').decode('utf-8')
            except:
                return ''
        return self.text.decode('utf-8')

class Click(SpookMixin, Base):
    """Model for storing mouse click information"""
    button = Column(Integer, nullable=False)
    x = Column(Integer, nullable=False)
    y = Column(Integer, nullable=False)
    nrmoves = Column(Integer, nullable=False, default=0)
    
    process_id = Column(Integer, ForeignKey('process.id'), nullable=False, index=True)
    window_id = Column(Integer, ForeignKey('window.id'), nullable=False)
    
    process = relationship("Process", backref=backref('clicks'))
    window = relationship("Window", backref=backref('clicks'))

    def __init__(self, button: int, x: int, y: int, process_id: int, window_id: int):
        self.button = button
        self.x = x
        self.y = y
        self.nrmoves = 0
        self.process_id = process_id
        self.window_id = window_id

    def __repr__(self) -> str:
        return f"<Click ({self.x}, {self.y}), button={self.button}>"

================
File: src/password_dialog.py
================
"""
Password dialog functionality for Selfspy
"""

import sys
import getpass
from typing import Optional, Callable
import tkinter as tk
from tkinter import simpledialog

def get_password(verify: Optional[Callable[[str], bool]] = None, 
                message: Optional[str] = None) -> str:
    """Get password from user through GUI or terminal"""
    
    if verify:
        pw = get_keyring_password(verify)
        if pw is not None:
            return pw
    
    return get_user_password(verify, message)

def get_user_password(verify: Optional[Callable[[str], bool]] = None,
                     message: Optional[str] = None,
                     force_save: bool = False) -> str:
    """Get password from user input"""
    
    if sys.stdin.isatty():
        return get_tty_password(verify, message, force_save)
    else:
        return get_tk_password(verify, message, force_save)

def get_keyring_password(verify: Callable[[str], bool],
                        message: Optional[str] = None) -> Optional[str]:
    """Try to get password from system keyring"""
    try:
        import keyring
        username = getpass.getuser()
        pw = keyring.get_password('Selfspy', username)
        
        if pw is not None:
            if verify(pw):
                return pw
            print('Stored keyring password is invalid.')
            pw = get_user_password(verify, message, force_save=True)
            return pw
            
    except ImportError:
        print('keyring library not found')
    
    return None

def set_keyring_password(password: str) -> None:
    """Store password in system keyring"""
    try:
        import keyring
        username = getpass.getuser()
        keyring.set_password('Selfspy', username, password)
    except ImportError:
        print('Unable to save password to keyring (library not found)')
    except Exception as e:
        print(f'Unable to save password to keyring: {e}')

def get_tty_password(verify: Optional[Callable[[str], bool]] = None,
                    message: Optional[str] = None,
                    force_save: bool = False) -> str:
    """Get password from terminal"""
    
    for _ in range(3):
        pw = getpass.getpass(message or 'Password: ')
        if not verify or verify(pw):
            break
    else:
        print('Password verification failed')
        sys.exit(1)

    if force_save or input("Save password to keyring? [y/N]: ").lower() == 'y':
        set_keyring_password(pw)

    return pw

def get_tk_password(verify: Optional[Callable[[str], bool]] = None,
                   message: Optional[str] = None,
                   force_save: bool = False) -> str:
    """Get password using tkinter dialog"""
    
    root = tk.Tk()
    root.withdraw()
    
    while True:
        dialog = PasswordDialog(
            title='Selfspy Password',
            prompt=message or 'Password:',
            parent=root
        )
        
        pw, save = dialog.result
        
        if pw is None:
            return ""
            
        if not verify or verify(pw):
            break
    
    if save or force_save:
        set_keyring_password(pw)
        
    return pw

class PasswordDialog(simpledialog.Dialog):
    """Custom password dialog with save option"""
    
    def __init__(self, title: str, prompt: str, parent: tk.Tk):
        self.prompt = prompt
        super().__init__(parent, title)

    def body(self, master: tk.Frame) -> tk.Entry:
        """Create dialog body"""
        tk.Label(master, text=self.prompt).grid(row=0, sticky=tk.W)
        
        self.password_entry = tk.Entry(master, show='*')
        self.password_entry.grid(row=0, column=1)
        
        self.save_var = tk.BooleanVar()
        tk.Checkbutton(master, 
                      text="Save to keyring",
                      variable=self.save_var).grid(row=1, columnspan=2, sticky=tk.W)
        
        return self.password_entry

    def apply(self) -> None:
        """Store results when OK is clicked"""
        self.result = (self.password_entry.get(), self.save_var.get())

if __name__ == '__main__':
    print(get_password())

================
File: src/selfspy.py
================
"""
Selfspy - Activity Monitor using pynput instead of PyObjC
"""

import os
import sys
import time
import hashlib
import argparse
from datetime import datetime
from typing import Optional, Dict, Any, List, Callable

from pynput import mouse, keyboard
from Crypto.Cipher import Blowfish
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Binary, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship

# Constants
DATA_DIR = os.path.expanduser('~/.selfspy')
DBNAME = 'selfspy.sqlite'
MAGIC_STRING = b'\xc5\x7fdh\x05\xf6\xc5=\xcfh\xafv\xc0\xf4\x13i*.O'

Base = declarative_base()

class Process(Base):
    __tablename__ = 'process'
    
    id = Column(Integer, primary_key=True)
    name = Column(String, index=True, unique=True)
    created_at = Column(DateTime, default=datetime.now, index=True)

class Window(Base):
    __tablename__ = 'window'
    
    id = Column(Integer, primary_key=True)
    title = Column(String, index=True)
    process_id = Column(Integer, ForeignKey('process.id'), nullable=False, index=True)
    created_at = Column(DateTime, default=datetime.now, index=True)
    
    process = relationship("Process", backref='windows')

class Keys(Base):
    __tablename__ = 'keys'
    
    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, default=datetime.now, index=True)
    text = Column(Binary, nullable=False)
    process_id = Column(Integer, ForeignKey('process.id'), nullable=False)
    window_id = Column(Integer, ForeignKey('window.id'), nullable=False)
    
    process = relationship("Process", backref='keys')
    window = relationship("Window", backref='keys')

class Click(Base):
    __tablename__ = 'click'
    
    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, default=datetime.now, index=True)
    button = Column(Integer, nullable=False)
    x = Column(Integer, nullable=False)
    y = Column(Integer, nullable=False)
    process_id = Column(Integer, ForeignKey('process.id'), nullable=False)
    window_id = Column(Integer, ForeignKey('window.id'), nullable=False)
    
    process = relationship("Process", backref='clicks')
    window = relationship("Window", backref='clicks')

class ActivityMonitor:
    def __init__(self, store: 'ActivityStore'):
        self.store = store
        self.current_window = None
        self.current_process = None
        self.buffer = []
        self.last_activity = time.time()
        
        # Initialize listeners
        self.keyboard_listener = keyboard.Listener(
            on_press=self.on_key_press,
            on_release=self.on_key_release
        )
        self.mouse_listener = mouse.Listener(
            on_move=self.on_mouse_move,
            on_click=self.on_mouse_click,
            on_scroll=self.on_scroll
        )

    def start(self):
        """Start monitoring"""
        self.keyboard_listener.start()
        self.mouse_listener.start()
        
        try:
            while True:
                self.check_active_window()
                self.flush_buffer()
                time.sleep(0.1)
        except KeyboardInterrupt:
            self.stop()

    def stop(self):
        """Stop monitoring"""
        self.keyboard_listener.stop()
        self.mouse_listener.stop()
        self.flush_buffer()

    def check_active_window(self):
        """Check current active window using AppKit"""
        try:
            import AppKit
            workspace = AppKit.NSWorkspace.sharedWorkspace()
            active_app = workspace.activeApplication()
            
            if active_app:
                process_name = active_app['NSApplicationName']
                window_title = self._get_active_window_title()
                
                if (process_name != self.current_process or 
                    window_title != self.current_window):
                    self.current_process = process_name
                    self.current_window = window_title
                    self.store.update_window_info(process_name, window_title)
                    
        except Exception as e:
            print(f"Error checking active window: {e}", file=sys.stderr)

    def _get_active_window_title(self) -> str:
        """Get the title of the active window"""
        try:
            import AppKit
            windows = AppKit.NSApplication.sharedApplication().windows()
            for window in windows:
                if window.isKeyWindow():
                    return window.title() or ''
        except:
            pass
        return ''

    def on_key_press(self, key):
        """Handle key press events"""
        try:
            if hasattr(key, 'char'):
                char = key.char
            else:
                char = str(key)
            
            self.buffer.append({
                'type': 'key',
                'key': char,
                'time': time.time()
            })
            self.last_activity = time.time()
            
        except Exception as e:
            print(f"Error handling key press: {e}", file=sys.stderr)

    def on_key_release(self, key):
        """Handle key release events"""
        pass

    def on_mouse_move(self, x, y):
        """Handle mouse movement"""
        self.last_activity = time.time()

    def on_mouse_click(self, x, y, button, pressed):
        """Handle mouse clicks"""
        if pressed:
            try:
                button_num = 1 if button == mouse.Button.left else 3
                self.store.store_click(button_num, x, y)
                self.last_activity = time.time()
            except Exception as e:
                print(f"Error handling mouse click: {e}", file=sys.stderr)

    def on_scroll(self, x, y, dx, dy):
        """Handle scroll events"""
        try:
            button_num = 4 if dy > 0 else 5
            self.store.store_click(button_num, x, y)
            self.last_activity = time.time()
        except Exception as e:
            print(f"Error handling scroll: {e}", file=sys.stderr)

    def flush_buffer(self):
        """Flush keystroke buffer to storage"""
        if self.buffer and time.time() - self.last_activity > 1.0:
            text = ''.join(item['key'] for item in self.buffer 
                          if isinstance(item.get('key'), str))
            if text:
                self.store.store_keys(text)
            self.buffer.clear()

class ActivityStore:
    def __init__(self, db_path: str, password: Optional[str] = None):
        self.engine = create_engine(f'sqlite:///{db_path}')
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)
        self.session = self.Session()
        
        if password:
            self.cipher = Blowfish.new(
                hashlib.md5(password.encode()).digest(),
                Blowfish.MODE_ECB
            )
        else:
            self.cipher = None
            
        self.current_process_id = None
        self.current_window_id = None

    def encrypt_text(self, text: str) -> bytes:
        """Encrypt text data"""
        if not self.cipher:
            return text.encode()
            
        padding = 8 - (len(text) % 8)
        padded_text = text + '\0' * padding
        return self.cipher.encrypt(padded_text.encode())

    def update_window_info(self, process_name: str, window_title: str):
        """Update current process and window information"""
        # Get or create process
        process = self.session.query(Process).filter_by(name=process_name).first()
        if not process:
            process = Process(name=process_name)
            self.session.add(process)
            self.session.commit()
            
        # Create new window
        window = Window(title=window_title, process_id=process.id)
        self.session.add(window)
        self.session.commit()
        
        self.current_process_id = process.id
        self.current_window_id = window.id

    def store_keys(self, text: str):
        """Store keystroke data"""
        if self.current_process_id and self.current_window_id:
            encrypted_text = self.encrypt_text(text)
            keys = Keys(
                text=encrypted_text,
                process_id=self.current_process_id,
                window_id=self.current_window_id
            )
            self.session.add(keys)
            self.session.commit()

    def store_click(self, button: int, x: int, y: int):
        """Store mouse click data"""
        if self.current_process_id and self.current_window_id:
            click = Click(
                button=button,
                x=x,
                y=y,
                process_id=self.current_process_id,
                window_id=self.current_window_id
            )
            self.session.add(click)
            self.session.commit()

    def close(self):
        """Clean up database connection"""
        self.session.close()

def main():
    parser = argparse.ArgumentParser(
        description='Monitor and store computer activity using pynput'
    )
    parser.add_argument(
        '-p', '--password',
        help='Encryption password for sensitive data'
    )
    parser.add_argument(
        '-d', '--data-dir',
        default=DATA_DIR,
        help='Data directory for storing the database'
    )
    parser.add_argument(
        '--no-text',
        action='store_true',
        help='Do not store text data (keystrokes)'
    )
    
    args = parser.parse_args()

    # Ensure data directory exists
    os.makedirs(args.data_dir, exist_ok=True)
    
    db_path = os.path.join(args.data_dir, DBNAME)
    store = ActivityStore(db_path, None if args.no_text else args.password)
    
    try:
        monitor = ActivityMonitor(store)
        monitor.start()
    except KeyboardInterrupt:
        print("\nShutting down gracefully...")
    finally:
        store.close()

if __name__ == '__main__':
    main()

================
File: tests/conftest.py
================
"""
Pytest configuration and fixtures
"""
import os
import sys
import tempfile
from pathlib import Path

import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import Session

# Add src to Python path
src_path = str(Path(__file__).parent.parent / 'src')
if src_path not in sys.path:
    sys.path.append(src_path)

from models import Base
from activity_store import ActivityStore

@pytest.fixture(scope="session")
def temp_dir():
    """Create a temporary directory for test data"""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield tmpdir

@pytest.fixture(scope="session")
def db_path(temp_dir):
    """Create a test database path"""
    return os.path.join(temp_dir, "test.db")

@pytest.fixture(scope="function")
def db_session(db_path):
    """Create a new database session for a test"""
    engine = create_engine(f"sqlite:///{db_path}")
    Base.metadata.create_all(engine)
    
    with Session(engine) as session:
        yield session
        
    Base.metadata.drop_all(engine)
    
@pytest.fixture(scope="function")
def activity_store(db_path):
    """Create a test activity store"""
    store = ActivityStore(db_path, password="test")
    yield store
    store.close()

================
File: tests/test_models.py
================
"""
Tests for database models
"""
import sys
from pathlib import Path

import pytest

# Add src to Python path
src_path = str(Path(__file__).parent.parent / 'src')
if src_path not in sys.path:
    sys.path.append(src_path)

from models import Process, Window

def test_process_creation(db_session):
    """Test creating a process"""
    process = Process(name="test_process")
    db_session.add(process)
    db_session.commit()
    
    retrieved = db_session.query(Process).filter_by(name="test_process").first()
    assert retrieved is not None
    assert retrieved.name == "test_process"

def test_window_creation(db_session):
    """Test creating a window with associated process"""
    # Create process first
    process = Process(name="test_process")
    db_session.add(process)
    db_session.commit()
    
    # Create window
    window = Window(title="test_window", process_id=process.id)
    db_session.add(window)
    db_session.commit()
    
    # Test retrieval
    retrieved = db_session.query(Window).filter_by(title="test_window").first()
    assert retrieved is not None
    assert retrieved.title == "test_window"
    assert retrieved.process.name == "test_process"

================
File: pyproject.toml
================
[tool.poetry]
name = "selfspy"
version = "1.0.0"
description = "A tool for monitoring and analyzing your computer activity"
authors = ["nuin <nuin@genedrift.org>"]
readme = "README.md"
packages = [{include = "src"}]
license = "GPL-3.0-or-later"

[tool.poetry.dependencies]
python = "^3.10"
SQLAlchemy = "^2.0.25"
pynput = "^1.7.6"
cryptography = "^41.0.7"
keyring = "^24.3.0"
python-dateutil = "^2.8.2"
click = "^8.1.7"
appdirs = "^1.4.4"
rich = "^13.7.0"
structlog = "^24.1.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.4"
pytest-cov = "^4.1.0"
black = "^23.12.1"
isort = "^5.13.2"
mypy = "^1.8.0"
ruff = "^0.1.11"
pre-commit = "^3.6.0"

[tool.poetry.scripts]
selfspy = "src.cli:main"
selfstats = "src.stats:main"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.pytest.ini_options]
pythonpath = ["src"]
testpaths = ["tests"]
addopts = "-ra -q --cov=src"

================
File: pytest.ini
================
[pytest]
pythonpath = src
testpaths = tests
python_files = test_*.py
addopts = -ra -q --cov=src

================
File: Readme.md
================
# Selfspy

A modern Python tool for monitoring and analyzing your computer activity.

## Description

Selfspy is a daemon that continuously monitors and stores what you are doing on your computer. This includes:
- Keystrokes (encrypted)
- Mouse movements and clicks
- Active window titles and processes
- Activity periods

Perfect for:
- Personal analytics
- Time tracking
- Activity monitoring
- Productivity analysis

## Requirements

- Python 3.10+
- MacOS 10.15+

## Installation

```bash
# Using Poetry
poetry install

# Or using pip
pip install .
```

## Usage

Start monitoring:
```bash
poetry run selfspy
```

View statistics:
```bash
poetry run selfstats
```

## Configuration

Default configuration is stored in `~/.selfspy/`. You can customize the location using:
```bash
poetry run selfspy --data-dir=/path/to/dir
```

## Security

- All keystroke data is encrypted using industry-standard encryption
- Password protection for sensitive data
- Local storage only - no data leaves your computer
- Option to disable text logging

## Contributing

1. Fork the repository
2. Create your feature branch
3. Install development dependencies: `poetry install --with dev`
4. Make your changes
5. Run tests: `poetry run pytest`
6. Submit a pull request

## License

GNU General Public License v3 (GPLv3)
